#include <Arduino.h>

#include "include/context.h"
#include "include/scheduler.h"
#include "include/task.h"

extern volatile task_t Tasks[NT];
extern volatile int cur_task;
extern volatile task_t* volatile cur_TCB; /*Change in assembly if name is
                                             changed */

#define d1 13
#define d2 12
#define d3 11
#define d4 10

void vTaskIncrementTick(void) {
  for (int x = 0; x < NT; x++) {
    if (Tasks[x].func) {
      if (Tasks[x].delay) {
        Tasks[x].delay--;
      } else {
        /* Schedule Task */
        Tasks[x].exec = 1;
        Tasks[x].delay = Tasks[x].period - 1;
      }
    }
  }
}

void vTaskSwitchContext(void) {
  for (int x = 0; x < NT; x++) {
    if ((Tasks[x].func) && (Tasks[x].exec)) {
      cur_task = x;
      cur_TCB = &(Tasks[cur_task]);  // Change in assembly if name is changed

      /* Delete task if one-shot */
      if (!Tasks[x].period) Tasks[x].func = 0;
      return;
    }
  }
}

void vPortYieldFromTick(void) __attribute__((naked));
void vPortYieldFromTick(void) {
  portSAVE_CONTEXT();

  vTaskIncrementTick();
  vTaskSwitchContext();

  portRESTORE_CONTEXT();
  asm volatile("ret");
}

void vPortYield(void) __attribute__((naked));
void vPortYield(void) {
  portSAVE_CONTEXT();
  vTaskSwitchContext();
  portRESTORE_CONTEXT();

  asm volatile("ret");
}

/* Interrupt service routine for the OS tick. */
ISR(TIMER1_COMPA_vect, ISR_NAKED) {
  vPortYieldFromTick();

  asm volatile("reti");
}

void StartScheduler(void) {
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;

  // OCR1A = 6250; // compare match register 16MHz/256/10Hz
  // OCR1A = 31250; // compare match register 16MHz/256/2Hz
  OCR1A = 31;               // compare match register 16MHz/256/2kHz
  TCCR1B |= (1 << WGM12);   // CTC mode
  TCCR1B |= (1 << CS12);    // 256 prescaler
  TIMSK1 |= (1 << OCIE1A);  // enable timer compare interrupt
  interrupts();

  // prvSetupTimerInterrupt();

  /* Restore the context of the first task that is going to run. */
  portRESTORE_CONTEXT();

  /* Simulate a function call end as generated by the compiler.  We will now
  jump to the start of the task the context of which we have just restored. */
  asm volatile("ret");
}

void t3(void) {
  while (1) {
    digitalWrite(d3, !digitalRead(d3));
    Tasks[cur_task].exec = 0;
    vPortYield();
  }
}

void t4(void) {
  while (1) {
    digitalWrite(d4, !digitalRead(d4));
    Tasks[cur_task].exec = 0;
    vPortYield();
  }
}

void idle(void) {
  while (1) {
    // Serial.println("Idle");
    digitalWrite(d1, !digitalRead(d1));
  }
}

// the setup function runs once when you press reset or power the board
void setup() {
  // Serial.begin(115200);
  // while (!Serial) {
  //   ;
  // }

  // initialize digital pin LED_BUILTIN as an output.
  pinMode(d4, OUTPUT);
  pinMode(d3, OUTPUT);
  pinMode(d2, OUTPUT);
  pinMode(d1, OUTPUT);
  digitalWrite(d4, !digitalRead(d4));
  digitalWrite(d3, !digitalRead(d3));
  digitalWrite(d2, !digitalRead(d2));
  digitalWrite(d1, !digitalRead(d1));

  Sched_Init();

  Sched_AddT(t3, 1 /* delay */, 1000 /* period */);
  Sched_AddT(t4, 1 /* delay */, 500 /* period */);
  Sched_AddT(idle, 1 /* delay */, 1 /* period */);

  StartScheduler();
}

// the loop function runs over and over again forever
void loop() { /* nothing to do */
}
