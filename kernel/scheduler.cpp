#include "include/scheduler.h"

#include <Arduino.h>

#include "include/context.h"
#include "include/task.h"

Task Tasks[NT];
volatile int cur_task = 0;
volatile StackType_t* volatile cur_TCB =
    Tasks[0].stackPointer;  // Change in assembly if name is changed


StackType_t stacks[1500] = {0};
int cur_stack_index = 0;

// /* Hardware constants for timer 1 on ATMega323. */
// #define portCLEAR_COUNTER_ON_MATCH (0x08)
// #define portPRESCALE_256 (0x04)
// #define portCLOCK_PRESCALER (256)
// #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE (0x10)
//
// /*
//  Setup timer 1 compare match A to generate a tick interrupt.
//  */
// static void prvSetupTimerInterrupt(void) {
//   unsigned long ulCompareMatch;
//   unsigned char ucHighByte, ucLowByte;

//   /* Generate the compare match value for our required tick
//   frequency. */
//   // ulCompareMatch = portCPU_CLOCK_HZ / portTICK_RATE_HZ;
//   ulCompareMatch = 31;

//   /* We only have 16 bits so have to scale to get our
//   required tick rate. */
//   ulCompareMatch /= portCLOCK_PRESCALER;

//   /* Setup compare match value for compare match A.
//   Interrupts are disabled before calling this function so
//   we need not bother here. [casting has been removed for
//   each of reading] */
//   ucLowByte = ulCompareMatch & 0xff;
//   ulCompareMatch >>= 8;
//   ucHighByte = ulCompareMatch & 0xff;
//   OCR1AH = ucHighByte;
//   OCR1AL = ucLowByte;

//   /* Setup clock source and compare match behaviour. */
//   ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_256;
//   TCCR1B = ucLowByte;

//   /* Enable the interrupt - this is okay as interrupt
//   are currently globally disabled. */
//   ucLowByte = TIMSK1;
//   ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
//   TIMSK1 = ucLowByte;
// }

int Sched_Init(void) {
  for (int x = 0; x < NT; x++) Tasks[x] = Task();
}

int Sched_AddTask(void (*f)(void), int d, int p) {
  for (int x = 0; x < NT; x++)
    if (!Tasks[x].func) {
      Tasks[x] = Task(f, d, p);
      return x;
    }
  return -1;
}

/* Called every tick */
void Sched_Schedule(void) {
  for (int x = 0; x < NT; x++) {
    if (Tasks[x].func) {
      if (Tasks[x].delay) {
        Tasks[x].delay--;
      } else {
        /* Schedule Task */
        Tasks[x].exec = 1;
        Tasks[x].delay = Tasks[x].period - 1;
      }
    }
  }
}

/* Called every tick */
void Sched_Dispatch(void) {
  for (int x = 0; x < NT; x++) {
    if ((Tasks[x].func) && (Tasks[x].exec)) {
      cur_task = x;
      cur_TCB = Tasks[cur_task].stackPointer;  // Change in assembly if name is changed

      /* Delete task if one-shot */
      if (!Tasks[x].period) Tasks[x].func = 0;
      return;
    }
  }
}

void Sched_Start(void) {
  // Setup interrupts
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;

  // OCR1A = 6250; // compare match register 16MHz/256/10Hz
  // OCR1A = 31250; // compare match register 16MHz/256/2Hz
  OCR1A = 31;               // compare match register 16MHz/256/2kHz
  TCCR1B |= (1 << WGM12);   // CTC mode
  TCCR1B |= (1 << CS12);    // 256 prescaler
  TIMSK1 |= (1 << OCIE1A);  // enable timer compare interrupt
  interrupts();

  // prvSetupTimerInterrupt();
  cur_TCB = Tasks[cur_task].stackPointer;

  /* Restore the context of the first task that is going to run. */
  portRESTORE_CONTEXT();

  /* Simulate a function call end as generated by the compiler.  We will now
  jump to the start of the task the context of which we have just restored. */
  asm volatile("ret");
}